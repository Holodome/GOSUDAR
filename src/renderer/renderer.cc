#include "renderer.hh"

#include "game/game.hh"

#define STB_IMAGE_IMPLEMENTATION
#include "thirdparty/stb_image.h"

static void APIENTRY
opengl_error_callback(GLenum source, GLenum type, GLenum id, GLenum severity, GLsizei length,
                      const GLchar* message, const void *_) {
    if (severity == GL_DEBUG_SEVERITY_NOTIFICATION) return;

    char *source_str;
    switch(source) {
        case GL_DEBUG_SOURCE_API_ARB: {
		    source_str = "Calls to OpenGL API";
        } break;
        case GL_DEBUG_SOURCE_WINDOW_SYSTEM_ARB: {
		    source_str = "Calls to window-system API";
        } break;
        case GL_DEBUG_SOURCE_SHADER_COMPILER_ARB: {
		    source_str = "A compiler for shading language"; 
        } break;
        case GL_DEBUG_SOURCE_THIRD_PARTY_ARB: {
		    source_str = "Application associated with OpenGL"; 
        } break;
        case GL_DEBUG_SOURCE_APPLICATION_ARB: {
		    source_str = "Generated by user"; 
        } break;
        case GL_DEBUG_SOURCE_OTHER_ARB: {
		    source_str = "Other"; 
        } break;
        default: {
		    source_str = "Unknown"; 
        } break;
    }

    char *type_str;
    switch (type) {
        case GL_DEBUG_TYPE_ERROR_ARB: {
		    type_str = "ERROR"; 
        } break;
        case GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR_ARB: {
		    type_str = "DEPRECATED_BEHAVIOR"; 
        } break;
        case GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR_ARB: {
		    type_str = "UNDEFINED_BEHAVIOR"; 
        } break;
        case GL_DEBUG_TYPE_PORTABILITY_ARB: {
		    type_str = "PORTABILITY";
        } break;
        case GL_DEBUG_TYPE_PERFORMANCE_ARB: {
		    type_str = "PERFORMANCE"; 
        } break;
        case GL_DEBUG_TYPE_OTHER_ARB: {
		    type_str = "OTHER"; 
        } break;
        default: {
		    type_str = "UNKNOWN"; 
        } break;
    }

    char *severity_str;
    switch(severity) {
        case GL_DEBUG_SEVERITY_NOTIFICATION: {
		    severity_str = "NOTIFICATION"; 
        } break;
        case GL_DEBUG_SEVERITY_LOW_ARB: {
		    severity_str = "LOW"; 
        } break;
        case GL_DEBUG_SEVERITY_MEDIUM_ARB: {
		    severity_str = "MEDIUM"; 
        } break;
        case GL_DEBUG_SEVERITY_HIGH_ARB: {
		    severity_str = "HIGH"; 
        } break;
        default: {
		    severity_str = "UNKNOWN"; 
        } break;
    }

    fprintf(stderr, "OpenGL Error Callback\n<Source: %s, type: %s, Severity: %s, ID: %u>:::\n%s\n",
			source_str, type_str, severity_str, id, message);
}

Image::Image(char *name) 
    : name(name) {
    size = Vec2i(0, 0);
    id = 0;
    stbi_set_flip_vertically_on_load(false);
    u8 *data = stbi_load(name, &size.x, &size.y, 0, 4);
    assert(data);
    glCreateTextures(GL_TEXTURE_2D, 1, &id);
    glTextureParameteri(id, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTextureParameteri(id, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glTextureParameteri(id, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTextureParameteri(id, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
    glTextureStorage2D(id, 1, GL_RGBA8, size.x, size.y);
    glTextureSubImage2D(id, 0, 0, 0, size.x, size.y, GL_RGBA, GL_UNSIGNED_BYTE, data);
    stbi_image_free(data);
    logprint("Image", "Image %s is loaded\n", name);
}

void Image::bind() {
    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_2D, id);
}

ImageLibrary::ImageLibrary() {
    
}

void ImageLibrary::init() {
    white = get("assets/white.png");
}

Image *ImageLibrary::get(char *name) {
    Image *result = 0;
    for (u32 i = 0; i < images.size; ++i) {
        Image *test = images[i];
        if (test->name.cmp(name)) {
            result = test;
        }
    }
    
    if (!result) {
        Image *image = new Image(name);
        images.add(image);
		result = image;
    }
    assert(result);
    return result;
}

Mesh::Mesh(char *name) 
    : name(name) {
    
}

// Mesh::Mesh(char *name, Vertex *v, size_t vc, u32 *i, size_t ic)
//     : name(name), ic(ic) {
//     init(v, vc, i, ic);
// }

void Mesh::init(Vertex *v, size_t vc, u32 *i, size_t ic) {
    this->ic = ic;
    glGenVertexArrays(1, &vao_id);
    glBindVertexArray(vao_id);
    glGenBuffers(1, &vbo_id);
    glBindBuffer(GL_ARRAY_BUFFER, vbo_id);
    glBufferData(GL_ARRAY_BUFFER, sizeof(Vertex) * vc, v, GL_STATIC_DRAW);
    glGenBuffers(1, &ibo_id);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ibo_id);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(u32) * ic, i, GL_STATIC_DRAW);
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void *)offsetof(Vertex, p));
    glEnableVertexAttribArray(0);
    glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void *)offsetof(Vertex, uv));
    glEnableVertexAttribArray(1);
    glVertexAttribPointer(2, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void *)offsetof(Vertex, n));
    glEnableVertexAttribArray(2);
    glVertexAttribPointer(3, 4, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void *)offsetof(Vertex, c));
    glEnableVertexAttribArray(3);
    logprint("Mesh", "Mesh %s is initialized\n", name.data);
}

void Mesh::bind() {
    glBindVertexArray(vao_id);
}

MeshLibrary::MeshLibrary() {
    
}

void MeshLibrary::init() {
    Vertex vertices[] = {
        {{0, 0, 0}, {0, 0}, {0, 0, 1}, {1, 0, 0, 1}},
        {{1, 0, 0}, {1, 0}, {0, 0, 1}, {0, 1, 0, 1}},
        {{0, 1, 0}, {0, 1}, {0, 0, 1}, {0, 0, 1, 1}},
        {{1, 1, 0}, {1, 1}, {0, 0, 1}, {1, 1, 1, 1}},
    };
    u32 indices[] = {
        0, 1, 3,
        0, 2, 3
    };
    Mesh *mesh = new Mesh("quad");
    mesh->init(vertices, ARRAY_SIZE(vertices), indices, ARRAY_SIZE(indices));
    quad = meshes[meshes.add(mesh)];
}

void MeshLibrary::add(Mesh *mesh) {
    meshes.add(mesh);
}

Mesh *MeshLibrary::get(char *name) {
    Mesh *result = 0;
    for (u32 i = 0; i < meshes.size; ++i) {
        Mesh *test = meshes[i];
        if (test->name.cmp(name)) {
            result = test;
        }
    }
    
    assert(result);
    return result;
}

Renderer::Renderer() {
    
}

void Renderer::init() {
    glEnable(GL_DEBUG_OUTPUT_SYNCHRONOUS_ARB);
    glDebugMessageCallback(opengl_error_callback, 0);
    
    char *shader_code = R"FOO(#ifdef VERTEX_SHADER

layout(location = 0) in vec4 p;
layout(location = 1) in vec2 uv;
layout(location = 2) in vec3 n;
layout(location = 3) in vec4 c;

out vec2 pass_uv;
out vec4 pass_c;
uniform mat4 mvp;

void main() {
    gl_Position = mvp * p;
    pass_uv = uv;
    pass_c = c;
}

#else

out vec4 out_c;

uniform sampler2D tex;

in vec2 pass_uv;
in vec4 pass_c;

void main() {
    out_c = pass_c * texture(tex, pass_uv);
}

#endif)FOO";

    GLuint vertex_shader = glCreateShader(GL_VERTEX_SHADER);
    GLuint fragment_shader = glCreateShader(GL_FRAGMENT_SHADER);
    const char *const vertex_source[] = { "#version 330\n", "#define VERTEX_SHADER\n", shader_code };
    const char *const fragment_source[] = { "#version 330\n", "", shader_code };
    glShaderSource(vertex_shader, ARRAY_SIZE(vertex_source), vertex_source, 0);
    glShaderSource(fragment_shader, ARRAY_SIZE(fragment_source), fragment_source, 0);
    glCompileShader(vertex_shader);
    glCompileShader(fragment_shader);
    
    GLint vertex_compiled, fragment_compiled;
    glGetShaderiv(vertex_shader, GL_COMPILE_STATUS, &vertex_compiled);
    glGetShaderiv(fragment_shader, GL_COMPILE_STATUS, &fragment_compiled);
    
    if (!(vertex_compiled && fragment_compiled)) {
        char shader_log[4096];
        if (!vertex_compiled) {
            glGetShaderInfoLog(vertex_shader, sizeof(shader_log), 0, shader_log);
            fprintf(stderr, "[ERROR] OpenGL vertex shader compilation failed: %s\n", shader_log);
        }
        if (!fragment_compiled) {
            glGetShaderInfoLog(fragment_shader, sizeof(shader_log), 0, shader_log);
            fprintf(stderr, "[ERROR] OpenGL fragment shader compilation failed: %s\n", shader_log);
        }
    }
    
    shader = glCreateProgram();
    glAttachShader(shader, vertex_shader);
    glAttachShader(shader, fragment_shader);
    glLinkProgram(shader);
    
    GLint link_success;
    glGetProgramiv(shader, GL_LINK_STATUS, &link_success);
    if (!link_success) {
        char program_log[4096];
        glGetProgramInfoLog(shader, sizeof(program_log), 0, program_log);
        fprintf(stderr, "[ERROR] OpenGL shader compilation failed: %s\n", program_log);
    }
 
    image_lib.init();
    mesh_lib.init();
    logprint("Renderer", "Initialized\n");
}

void Renderer::set_mats(Mat4x4 projection, Mat4x4 view) {
    this->projection = projection;
    this->view = view;    
}

void Renderer::begin_frame(Vec2 win_size) {
    glEnable(GL_DEPTH_TEST);
    glEnable(GL_SCISSOR_TEST);
    glDepthMask(GL_TRUE);
    glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
    glDepthFunc(GL_LEQUAL);
    glCullFace(GL_BACK);
    glFrontFace(GL_CCW);
    glProvokingVertex(GL_FIRST_VERTEX_CONVENTION);
    glEnable(GL_BLEND);
    glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
    glViewport(0, 0, win_size.x, win_size.y);
    glScissor(0, 0, win_size.x, win_size.y); 
    glClearColor(0.2, 0.2, 0.2, 1.0);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    
    glUseProgram(shader);
    
    Mat4x4 pm = Mat4x4::ortographic_2d(0, game->input.winsize.x, game->input.winsize.y, 0);
    Mat4x4 vm = Mat4x4::identity();
    set_mats(pm, vm);
}

void Renderer::draw_mesh(Mesh *mesh, Image *diffuse, Vec3 p, Quat4 ori, Vec3 s) {
    mesh->bind();
    diffuse->bind();
    glUniform1i(glGetUniformLocation(shader, "tex"), 0);
    Mat4x4 modelm = Mat4x4::identity() * Mat4x4::translate(p) * Quat4::to_mat4x4(ori) * Mat4x4::scale(s);
    Mat4x4 mvp = projection * view * modelm;
    glUniformMatrix4fv(glGetUniformLocation(shader, "mvp"), 1, false, mvp.value_ptr());
    glDrawElements(GL_TRIANGLES, mesh->ic, GL_UNSIGNED_INT, 0);
}
