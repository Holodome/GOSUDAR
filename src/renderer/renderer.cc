#include "renderer.hh"

#define STB_IMAGE_IMPLEMENTATION
#include "thirdparty/stb_image.h"

static void APIENTRY
opengl_error_callback(GLenum source, GLenum type, GLenum id, GLenum severity, GLsizei length,
                      const GLchar* message, const void *_) {
    if (severity == GL_DEBUG_SEVERITY_NOTIFICATION) return;

    char *source_str;
    switch(source) {
        case GL_DEBUG_SOURCE_API_ARB: {
		    source_str = "Calls to OpenGL API";
        } break;
        case GL_DEBUG_SOURCE_WINDOW_SYSTEM_ARB: {
		    source_str = "Calls to window-system API";
        } break;
        case GL_DEBUG_SOURCE_SHADER_COMPILER_ARB: {
		    source_str = "A compiler for shading language"; 
        } break;
        case GL_DEBUG_SOURCE_THIRD_PARTY_ARB: {
		    source_str = "Application associated with OpenGL"; 
        } break;
        case GL_DEBUG_SOURCE_APPLICATION_ARB: {
		    source_str = "Generated by user"; 
        } break;
        case GL_DEBUG_SOURCE_OTHER_ARB: {
		    source_str = "Other"; 
        } break;
        default: {
		    source_str = "Unknown"; 
        } break;
    }

    char *type_str;
    switch (type) {
        case GL_DEBUG_TYPE_ERROR_ARB: {
		    type_str = "ERROR"; 
        } break;
        case GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR_ARB: {
		    type_str = "DEPRECATED_BEHAVIOR"; 
        } break;
        case GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR_ARB: {
		    type_str = "UNDEFINED_BEHAVIOR"; 
        } break;
        case GL_DEBUG_TYPE_PORTABILITY_ARB: {
		    type_str = "PORTABILITY";
        } break;
        case GL_DEBUG_TYPE_PERFORMANCE_ARB: {
		    type_str = "PERFORMANCE"; 
        } break;
        case GL_DEBUG_TYPE_OTHER_ARB: {
		    type_str = "OTHER"; 
        } break;
        default: {
		    type_str = "UNKNOWN"; 
        } break;
    }

    char *severity_str;
    switch(severity) {
        case GL_DEBUG_SEVERITY_NOTIFICATION: {
		    severity_str = "NOTIFICATION"; 
        } break;
        case GL_DEBUG_SEVERITY_LOW_ARB: {
		    severity_str = "LOW"; 
        } break;
        case GL_DEBUG_SEVERITY_MEDIUM_ARB: {
		    severity_str = "MEDIUM"; 
        } break;
        case GL_DEBUG_SEVERITY_HIGH_ARB: {
		    severity_str = "HIGH"; 
        } break;
        default: {
		    severity_str = "UNKNOWN"; 
        } break;
    }

    fprintf(stderr, "OpenGL Error Callback\n<Source: %s, type: %s, Severity: %s, ID: %u>:::\n%s\n",
			source_str, type_str, severity_str, id, message);
}

Image::Image(char *name) 
    : name(name) {
    size = Vec2i(0, 0);
    id = 0;
    is_loaded = false;    
}

void Image::load() {
    stbi_set_flip_vertically_on_load(true);
    u8 *data = stbi_load(name.data, &size.x, &size.y, 0, 4);
    assert(data);
    glCreateTextures(GL_TEXTURE_2D, 1, &id);
    glTextureParameteri(id, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTextureParameteri(id, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glTextureParameteri(id, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTextureParameteri(id, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
    glTextureStorage2D(id, 1, GL_RGBA8, size.x, size.y);
    glTextureSubImage2D(id, 0, 0, 0, size.x, size.y, GL_RGBA, GL_UNSIGNED_BYTE, data);
    Mem::free(data);
    is_loaded = true;
}

void Image::bind() {
    if (!is_loaded) {
        load();
    }
    
    glActiveTexture(GL_TEXTURE_2D);
    glBindTexture(GL_TEXTURE_2D, id);
}

ImageLibrary::ImageLibrary() {
    
}

void ImageLibrary::init() {
    white = get("assets/white.png");
}

Image *ImageLibrary::get(char *name) {
    Image *result = 0;
    for (u32 i = 0; i < images.size; ++i) {
        Image *test = &images[i];
        if (test->name.cmp(name)) {
            result = test;
        }
    }
    
    if (!result) {
        Image image = Image(name);
        image.load();
        images.add(image);
    }
    
    return result;
}

Renderer::Renderer() {
    
}

void Renderer::init() {
    glEnable(GL_DEBUG_OUTPUT_SYNCHRONOUS_ARB);
    glDebugMessageCallback(opengl_error_callback, 0);
    
    char *shader_code = R"FOO(#ifdef VERTEX_SHADER

layout(location = 0) in vec4 p;
layout(location = 1) in vec2 uv;
layout(location = 2) in vec3 n;
layout(location = 3) in vec4 c;

out vec2 out_uv;
out vec4 out_c;
uniform mat4 mvp;

void main() {
    gl_Position = mvp * p;
    out_uv = uv;
    out_c = c;
}

#else

out vec4 out_c;

uniform sampler2D tex;

in vec2 in_uv;
in vec4 in_c;

void main() {
    out_c = in_c * texture(tex, in_uv);
}

#endif)FOO";

    GLuint vertex_shader = glCreateShader(GL_VERTEX_SHADER);
    GLuint fragment_shader = glCreateShader(GL_FRAGMENT_SHADER);
    const char * const vertex_source[] = { "#version 330\n", "#define VERTEX_SHADER\n", shader_code };
    const char * const fragment_source[] = { "#version 330\n", "#define FRAGMENT_SHADER\n", shader_code };
    glShaderSource(vertex_shader, ARRAY_SIZE(vertex_source), vertex_source, 0);
    glShaderSource(fragment_shader, ARRAY_SIZE(fragment_source), fragment_source, 0);
    glCompileShader(vertex_shader);
    glCompileShader(fragment_shader);
    
    GLint vertex_compiled, fragment_compiled;
    glGetShaderiv(vertex_shader, GL_COMPILE_STATUS, &vertex_compiled);
    glGetShaderiv(fragment_shader, GL_COMPILE_STATUS, &fragment_compiled);
    
    if (!(vertex_compiled && fragment_compiled)) {
        char shader_log[4096];
        if (!vertex_compiled) {
            glGetShaderInfoLog(vertex_shader, sizeof(shader_log), 0, shader_log);
            fprintf(stderr, "[ERROR] OpenGL vertex shader compilation failed: %s\n", shader_log);
        }
        if (!fragment_compiled) {
            glGetShaderInfoLog(fragment_shader, sizeof(shader_log), 0, shader_log);
            fprintf(stderr, "[ERROR] OpenGL fragment shader compilation failed: %s\n", shader_log);
        }
    }
    
    shader = glCreateProgram();
    glAttachShader(shader, vertex_shader);
    glAttachShader(shader, fragment_shader);
    glLinkProgram(shader);
    
    GLint link_success;
    glGetProgramiv(shader, GL_LINK_STATUS, &link_success);
    if (!link_success) {
        char program_log[4096];
        glGetProgramInfoLog(shader, sizeof(program_log), 0, program_log);
        fprintf(stderr, "[ERROR] OpenGL shader compilation failed: %s\n", program_log);
    }
 
    image_lib.init();
}

void Renderer::begin_frame(Vec2 win_size) {
    glEnable(GL_DEPTH_TEST);
    glEnable(GL_SCISSOR_TEST);
    glDepthMask(GL_TRUE);
    glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
    glDepthFunc(GL_LEQUAL);
    glCullFace(GL_BACK);
    glFrontFace(GL_CCW);
    glProvokingVertex(GL_FIRST_VERTEX_CONVENTION);
    glEnable(GL_BLEND);
    glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
    glViewport(0, 0, win_size.x, win_size.y);
    glScissor(0, 0, win_size.x, win_size.y); 
    glClearColor(0.2, 0.2, 0.2, 1.0);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    
    glUseProgram(shader);
}

Mesh::Mesh(char *name) {
    
}

void Mesh::load() {
    
}

MeshLibrary::MeshLibrary() {
    
}

void MeshLibrary::init() {
    
}

Mesh *MeshLibrary::get(char *name) {
    return 0;
}


#if 0 
void Renderer::render() {
   
    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_2D_ARRAY, texture_array);
    for (u32 render_quads_index = 0;
            render_quads_index < render_quads_count;
            ++render_quads_index) {
        RenderQuads quads = render_quads[render_quads_index];
        
        glDrawElementsBaseVertex(GL_TRIANGLES, 6 * quads.quad_count, GL_UNSIGNED_SHORT,
                                    (GLvoid *)(sizeof(u16) * quads.index_array_offset),
                                    quads.vertex_array_offset);
    }
}

RendererTexture Renderer::make_texture(u32 w, u32 h, u8 *pix) {
    RendererTexture tex = {0};
    tex.w = w;
    tex.h = h;
    tex.index = texture_array_size++;
    assert(texture_array_size < texture_array_capacity);
    
    glBindTexture(GL_TEXTURE_2D_ARRAY, texture_array);
    glTexSubImage3D(GL_TEXTURE_2D_ARRAY, 0, 0, 0,
                    tex.index, w, h, 1, 
                    GL_RGBA, GL_UNSIGNED_BYTE, pix);
    
    return tex;
}

void Renderer::quad(Vec3 v0, Vec3 v1, Vec3 v2, Vec3 v3, 
                    Vec4 c0, Vec4 c1, Vec4 c2, Vec4 c3,
                    Vec2 uv0, Vec2 uv1, Vec2 uv2, Vec2 uv3,
                    RendererTexture tex) {
    assert(render_quads_count + 1 <= render_quads_capacity);
    RenderQuads *quads = render_quads + render_quads_count++;
    quads->quad_count = 1;
    quads->index_array_offset = index_buffer_size;
    quads->vertex_array_offset = vertex_buffer_size;
    
    if (tex == EMPTY_TEXTURE) {
        tex = white_tex;
    }
    u32 texture_index = tex.index;
    // @NOTE(hl): Transpose uvs from normalized space, to texture in texture array space
    // Vec2 array_size = renderer_settings.texture_size;
    Vec2 array_texture_size   = Vec2(512, 512);
    Vec2 current_texture_size = Vec2(tex.w, tex.h);
    Vec2 uv_scale = current_texture_size / array_texture_size;
    uv0 = uv0 * uv_scale;
    uv1 = uv1 * uv_scale;
    uv2 = uv2 * uv_scale;
    uv3 = uv3 * uv_scale;

    u32 packed_color0 = pack_rgba_4x8_linear1(c0);
    u32 packed_color1 = pack_rgba_4x8_linear1(c1);
    u32 packed_color2 = pack_rgba_4x8_linear1(c2);
    u32 packed_color3 = pack_rgba_4x8_linear1(c3);

    // Vertex buffer
    Vertex *vbuf = vertex_buffer + vertex_buffer_size;
    vbuf[0].pos = v0;
    vbuf[0].uv  = uv0;
    vbuf[0].rgba = packed_color0;
    vbuf[0].texture_index = texture_index;

    vbuf[1].pos = v1;
    vbuf[1].uv  = uv1;
    vbuf[1].rgba = packed_color1;
    vbuf[1].texture_index = texture_index;

    vbuf[2].pos = v2;
    vbuf[2].uv  = uv2;
    vbuf[2].rgba = packed_color2;
    vbuf[2].texture_index = texture_index;

    vbuf[3].pos = v3;
    vbuf[3].uv  = uv3;
    vbuf[3].rgba = packed_color3;
    vbuf[3].texture_index = texture_index;

    // Index buffer
    u16 *ibuf = index_buffer + index_buffer_size;
    u16  base_index   = vertex_buffer_size - quads->vertex_array_offset;
    ibuf[0] = base_index + 0;
    ibuf[1] = base_index + 2;
    ibuf[2] = base_index + 3;
    ibuf[3] = base_index + 0;
    ibuf[4] = base_index + 1;
    ibuf[5] = base_index + 3;

    // Update buffer sizes after we are finished.
    vertex_buffer_size += 4;
    index_buffer_size  += 6;                    
}

void Renderer::rect(Rect rect, RendererTexture tex, Vec4 color) {
    Vec3 rect_pts[4];
    rect.store_points(rect_pts);
    quad(rect_pts[0], rect_pts[1], rect_pts[2], rect_pts[3],
         color, color, color, color, 
         Vec2(0, 0), Vec2(0, 1), Vec2(1, 0), Vec2(0, 1),
         tex);
}


void Renderer::rect_bounds(Vec2 min, Vec2 max, Vec4 color, f32 thickness) {
    rect(Rect::minmax(min, Vec2(max.x, min.y + thickness)), white_tex, color);
    rect(Rect::minmax(min, Vec2(min.x + thickness, max.y)), white_tex, color);
    rect(Rect::minmax(Vec2(min.x, max.y - thickness), max), white_tex, color);
    rect(Rect::minmax(Vec2(max.x - thickness, min.y), max), white_tex, color);
}


void Renderer::text(Vec2 p, Vec4 c, char *text, Font *font, f32 scale) {
    f32 line_height = font->height * scale;

	f32 rwidth  = 1.0f / (f32)font->atlas.w;
	f32 rheight = 1.0f / (f32)font->atlas.h;

	Vec3 offset = Vec3(p, 0);
	offset.y += line_height;

	for (char *scan = text; *scan; ++scan) {
		char symbol = *scan;

		if ((symbol >= font->first_codepoint) && (symbol < font->first_codepoint + font->glyphs.size)) {
			FontGlyph *glyph = &font->glyphs[symbol - font->first_codepoint];

			f32 glyph_width  = (glyph->offset2_x - glyph->offset1_x) * scale;
			f32 glyph_height = (glyph->offset2_y - glyph->offset1_y) * scale;


			f32 y1 = offset.y + glyph->offset1_y * scale;
			f32 y2 = y1 + glyph_height;
			f32 x1 = offset.x + glyph->offset1_x * scale;
			f32 x2 = x1 + glyph_width;

			f32 s1 = glyph->min_x * rwidth;
			f32 t1 = glyph->min_y * rheight;
			f32 s2 = glyph->max_x * rwidth;
			f32 t2 = glyph->max_y * rheight;

			quad(Vec3(x1, y1, 0), Vec3(x1, y2, 0), Vec3(x2, y1, 0), Vec3(x2, y2, 0),
				 c, c, c, c,
				 Vec2(s1, t1), Vec2(s1, t2), Vec2(s2, t1), Vec2(s2, t2),
				 font->atlas);

			f32 char_advance = glyph->x_advance * scale;
			offset.x += char_advance;
		}
	}
}

#endif 